<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>×¡×™×™×¢×Ÿ ×”××¡××›×™×</title>
<link href="css/tailwind.min.css" rel="stylesheet">
<script src="js/htmx.org@2.0.2"></script>
<script src="js/marked.min.js"></script>
<style>
	html, body           { height: 100%; min-height: 0; }
	.flex-container      { height: 100%; min-height: 0; }   /* new */

	.pdf-table-wrapper {
	  max-height: 500px;
	  overflow-y: auto;
	}
	.delete-conv-btn { color: #9ca3af; font-size: 0.9rem; }
	.chat-list-item:hover .delete-conv-btn { color: #ef4444; }

	/* keep the header visible while scrolling */
	#pdfTable thead th {
	  position: sticky;
	  top: 0;
	  background: #f3f4f6;     /* same colour you use already */
	  z-index: 1;
	}

	/* Delete confirm popover */
	.delete-popover {
	  position: absolute;
	  z-index: 60000;
	  min-width: 220px;
	  max-width: 320px;
	  border-radius: 0.5rem;
	  box-shadow: 0 10px 30px rgba(2,6,23,0.2);
	  background: white;
	  padding: 0.5rem;
	  font-size: 0.95rem;
	  transform-origin: top right;
	  animation: popIn 120ms ease-out;
	}

	.delete-popover:focus { outline: none; }

	/* little arrow */
	.delete-popover::before {
	  content: "";
	  position: absolute;
	  width: 0;
	  height: 0;
	  border-left: 8px solid transparent;
	  border-right: 8px solid transparent;
	  border-bottom: 8px solid white;
	  top: -8px;
	  right: 12px;
	  filter: drop-shadow(0 -2px 2px rgba(0,0,0,0.05));
	}

	/* subtle pop-in */
	@keyframes popIn {
	  from { opacity: 0; transform: translateY(-6px) scale(.98); }
	  to   { opacity: 1; transform: translateY(0) scale(1); }
	}

	/* Buttons inside popover */
	.delete-popover .pop-actions {
	  display: flex;
	  gap: 0.5rem;
	  justify-content: flex-end;
	  margin-top: 0.5rem;
	}
	.pop-confirm {
	  background-color: #ef4444; /* red-500 */
	  color: white;
	  padding: 0.35rem 0.7rem;
	  border-radius: 0.375rem;
	  border: none;
	  cursor: pointer;
	  font-weight: 600;
	}
	.pop-cancel {
	  background: transparent;
	  color: #374151; /* gray-700 */
	  padding: 0.35rem 0.6rem;
	  border-radius: 0.375rem;
	  border: 1px solid #e5e7eb;
	  cursor: pointer;
	}

	/* subtle hover states */
	.pop-confirm:hover { filter: brightness(0.95); }
	.pop-cancel:hover { background: #f8fafc; }


	/* keep tableâ€layout fixed so colgroup is honored */
	#uploadSection table {
	  width: 100%;
	  table-layout: fixed;
	  border-collapse: collapse;
	}

	/* vertical separator */
	#uploadSection td + td,
	#uploadSection th + th {
	  border-left: 2px solid #e5e7eb;
	}

	/* padding, wrapping, header style */
	#uploadSection th,
	#uploadSection td {
	  padding: 0.75rem;
	  white-space: normal;
	  overflow-wrap: anywhere;
	  border-bottom: 1px solid #e5e7eb;
	}

	#uploadSection thead th {
	  background: #f3f4f6;
	  font-weight: 600;
	  border-bottom: 2px solid #e5e7eb;
	}


	#pdfList {
	  width: 100%;
	  table-layout: fixed;
	  border-collapse: collapse;
	  font-size: 0.875rem;
	}

	html[dir="ltr"] label,
	html[dir="ltr"] #uploadedDocumentsTitle {
	  text-align: left;
	}

	#chatMessages > .flex {
	  margin-top: 5px;
	  margin-bottom: 5px;
	}

	#toggleThinkingDisplay {
	  white-space: nowrap;
	}

	@keyframes zoomOutIn {
	  0% {
	    transform: scale(1);
	    opacity: 1;
	  }
	  50% {
	    transform: scale(0.8);
	    opacity: 0;
	  }
	  100% {
	    transform: scale(1);
	    opacity: 1;
	  }
	}

	.response-message.transition-zoom {
	  animation: zoomOutIn 0.6s ease-in-out;
	}

  .flex-container {
	position: relative;
	display: flex;
	flex-direction: row;
	flex: 1;
	overflow: visible;
  }
  #uploadSection {
    width: 350px;
	transition: width 0.3s ease, padding 0.3s ease;
	padding: 2.5rem 1.5rem 1.5rem 1.5rem; 
    background: #ffffff;
    border-radius: 0.75rem;
    display: flex;
    flex-direction: column;
    align-items: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
    position: relative;
	overflow: visible;
	min-height: 0;
	position: relative;
	z-index: 10;
	height: 100%;
	min-height: 0;         
  }
  #uploadSection.shrunk {
    width: 300px;
    padding: 1rem;
    border-right: 2px solid #e2e8f0;
    box-shadow: 2px 0 8px rgba(0, 0, 0, 0.08);
    background: #f8fafc;
  }
  #uploadSection h1 {
    font-size: 1.5rem;
    color: #1e40af;
    margin-bottom: 1rem;
    font-weight: 600;
  }
  #uploadSection.shrunk h1 {
    font-size: 1rem;
    margin-bottom: 0.75rem;
    text-align: center;
  }
  #uploadSection label {
    font-size: 1rem;
    color: #1f2937;
    margin-bottom: 0.5rem;
    font-weight: 500;
  }
  #sourceFile {
    font-size: 0.875rem;
    padding: 0.5rem;
    margin-bottom: 1rem;
    border: 1px solid #d1d5db;
    border-radius: 0.375rem;
    width: 100%;
    background: #f9fafb;
  }
  #uploadButton {
    font-size: 1rem;
    padding: 0.5rem 1rem;
    background-color: #1e40af;
    color: white;
    border-radius: 0.375rem;
    width: 100%;
    transition: background-color 0.2s ease;
  }
  #uploadButton:hover {
    background-color: #1e3a8a;
  }
  #toggleButton {
	top: 0.75rem;
	z-index: 50000;
    position: absolute;
    top: 0.75rem;
    width: 24px;
    height: 24px;
    background-color: #e2e8f0;
    border: 1px solid #cbd5e1;
    border-radius: 9999px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-weight: bold;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    right: auto;
    left: auto;
    transition: left 0.3s ease, right 0.3s ease;
  }

  #success, #error {
    font-size: 0.875rem;
    margin-top: 0.5rem;
    text-align: center;
  }
  #success {
    color: #15803d;
  }
  #error {
    color: #b91c1c;
  }
  .chat-section [dir="rtl"] {
    direction: rtl;
    text-align: right;
  }
  .chat-section {
    flex: 1 1 0;
    display: flex;
	min-height: 0;
	overflow: hidden; 
    flex-direction: column;
    padding: 2rem;
    background: #f1f5f9;
	position: relative;
	z-index: 1;
  }
  
  #chatMessages {
    flex: 1 1 auto;
	min-height: 0; 
    overflow-y: auto;
    padding: 1.5rem;
    background-color: #ffffff;
    border-radius: 0.75rem;
    margin-bottom: 1rem;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    display: flex;
    flex-direction: column;
  }
  #chatInput {
    padding: 0.75rem;
    font-size: 1rem;
    border: 1px solid #d1d5db;
    border-radius: 0.375rem;
    width: 100%;
  }
  #sendButton {
    padding: 0.75rem 1.5rem;
    font-size: 1rem;
    background-color: #1e40af;
    color: white;
    border-radius: 0.375rem;
    transition: background-color 0.2s ease;
  }
  #sendButton:hover {
    background-color: #1e3a8a;
  }
  
  .thinking-text {
    font-style: italic;
    color: #6b7280;
    overflow: hidden;
    white-space: normal;
    display: -webkit-box;
    -webkit-line-clamp: 10;
    -webkit-box-orient: vertical;
    line-height: 1.4em;
    max-height: 24em;
    word-break: break-word;
    width: 640px;
	padding-top: 0.6em;
	padding-bottom: 0.6em;
	box-sizing: border-box;
	-webkit-mask-image: linear-gradient(to bottom, transparent, black 10%, black 90%, transparent);
	mask-image: linear-gradient(to bottom, transparent, black 10%, black 90%, transparent);
  }

  .thinking-indicator {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }
  .thinking-indicator img {
    width: 20px;
    height: 20px;
    animation: pulse 1.5s infinite ease-in-out;
  }
  .thinking-indicator span {
    font-style: italic;
    color: #6b7280;
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: normal;
    line-height: 1.2rem;
    max-height: 3.6rem;
  }

  @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
  }

  .chat-section .justify-end > div { /* user bubble */
    padding: 1rem;
  }

  .response-message.is-thinking {
    max-height: 4.5em !important;
    height: 4.5em !important;
    overflow: hidden !important;
    display: flex !important;
    align-items: center !important;
    justify-content: flex-end !important;
    direction: rtl !important;
    text-align: right !important;
    padding: 0.75rem 1.5rem !important;
    gap: 0.5rem !important;
    transform: scale(0.95);
    opacity: 0.7;
    box-shadow: 0 0 10px rgba(30, 64, 175, 0.4);
    transition: all 0.6s ease-in-out;
	max-width: 640px !important;
  }

  .response-message.is-thinking.hide-thinking-message {
      opacity: 0 !important;
      max-height: 0 !important;
      padding-top: 0 !important;
      padding-bottom: 0 !important;
      box-shadow: none !important;
      border: none !important;
  }

  .thinking-glow {
     box-shadow: 0 0 15px rgba(30, 64, 175, 0.8), 0 0 20px rgba(30, 64, 175, 0.6);
  }

  .bg-indigo-500,
  .response-message {
    transition: all 0.6s ease-in-out;
    transform-origin: center center;
	overflow-wrap: anywhere;
    max-width: 600px;
  }

  .response-message.final-answer {
    height: auto !important;
    padding: 1rem !important;
    opacity: 1 !important;
    transform: scale(1) !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    max-width: 600px !important; 
    max-height: none !important;
  }
 
  #pdfList th,
  #pdfList td {
    padding: 0.75rem;
    text-align: left;
    border-bottom: 1px solid #e5e7eb;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  #pdfList td + td,
  #pdfList th + th {
    border-left: 2px solid #e5e7eb;
  }

  #pdfList thead th {
    background-color: #f3f4f6;
    font-weight: 600;
    font-size: 0.875rem;
  }

  #pdfList tbody td {
    padding: 0.75rem;
    border-bottom: 1px solid #e5e7eb;
  }
  #pdfList tbody td + td {
    border-left: 2px solid #e5e7eb;
  }
  .filename-cell {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    direction: ltr;
    text-align: left;
  }

  html[dir="rtl"] .filename-cell {
    text-align: right;
  }
  html[dir="rtl"] #pdfList th,
  html[dir="rtl"] #pdfList td {
	text-align: right;
  }
  #pdfTable th {
    text-align: left;
  }
  html[dir="rtl"] #pdfTable th {
    text-align: right;
    direction: rtl;
  }

  /* ===== Chats list styles ===== */
  #chatsSection {
    width: 100%;
    margin-top: 1rem;
  }
  #chatList {
    list-style: none;
    padding: 0;
    margin-top: 0.5rem;
    max-height: 220px;
    overflow-y: auto;
    border: 1px solid #e5e7eb;
    border-radius: 0.5rem;
  }
  .chat-list-item {
    padding: 0.5rem 0.75rem;
    border-bottom: 1px solid #f1f5f9;
    cursor: pointer;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .chat-list-item:last-child {
    border-bottom: none;
  }
  .chat-list-item.active {
    background-color: #e0e7ff;
    font-weight: 600;
  }
  #newChatBtn {
    width: 100%;
    margin-top: 0.5rem;
    padding: 0.5rem 0.75rem;
    border-radius: 0.375rem;
    background-color: #1e40af;
    color: #fff;
    transition: background-color 0.2s ease;
  }
  #newChatBtn:hover {
    background-color: #1e3a8a;
  }
  /* ================================ */
  </style>

  <script>
	// store thinking DOM elements per conversation so we can reattach them after switching
	const thinkingElementsByConversation = {};

	// maps UIâ€lang â†’ (code â†’ human label)
	const langLabels = {
	  en: { en: "English", he: "Hebrew" },
	  he: { en: "×× ×’×œ×™×ª", he: "×¢×‘×¨×™×ª" }
	};

    let showThinkingBlock = true;
    let currentThinkingMessageElement = null;

    // === Conversations state ===
    let activeConversationId = null;

	// Manage a single open popover at a time
	let currentDeletePopover = null;

	function showDeletePopover(anchorEl, options) {
	  // options: { id, title, onConfirm, message }
	  hideDeletePopover(); // close any other

	  const pop = document.createElement('div');
	  pop.className = 'delete-popover';
	  pop.tabIndex = -1; // focusable for keyboard handling
	  pop.setAttribute('role', 'dialog');
	  pop.setAttribute('aria-modal', 'false');

	  const msg = options.message || translations[userLang]?.confirmDeleteConversation || "Delete conversation?";
	  const safeTitle = escapeHtml(options.title || options.id);

	  pop.innerHTML = `
	    <div style="display:flex; gap:0.6rem; align-items:flex-start;">
	      <div style="flex:1">
	        <div style="font-weight:600; margin-bottom:0.25rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${escapeHtml(safeTitle)}</div>
	        <div style="color:#6b7280; font-size:0.9rem;">${escapeHtml(msg)}</div>
	      </div>
	    </div>
	    <div class="pop-actions">
	      <button class="pop-cancel" type="button">${escapeHtml(translations[userLang]?.cancelBtn || "Cancel")}</button>
	      <button class="pop-confirm" type="button">${escapeHtml(translations[userLang]?.confirmDeleteBtn || "Delete")}</button>
	    </div>
	  `;

	  document.body.appendChild(pop);

	  // position near anchorEl (right-aligned by default)
	  const rect = anchorEl.getBoundingClientRect();
	  const top = rect.top + window.scrollY + rect.height + 8; // below the anchor
	  // prefer placing popover such that its arrow matches anchor (right side)
	  const right = window.innerWidth - (rect.left + window.scrollX) - 8;
	  pop.style.top = `${top}px`;
	  pop.style.right = `${right}px`;

	  // event handlers
	  const btnCancel = pop.querySelector('.pop-cancel');
	  const btnConfirm = pop.querySelector('.pop-confirm');

	  btnCancel.addEventListener('click', () => {
	    hideDeletePopover();
	    if (typeof options.onCancel === 'function') options.onCancel();
	  });

	  btnConfirm.addEventListener('click', async () => {
	    // disable buttons while request in-flight
	    btnConfirm.disabled = true;
	    btnCancel.disabled = true;
	    try {
	      await options.onConfirm();
	    } catch (err) {
	      console.error('Delete failed', err);
	      alert(translations[userLang]?.deleteFailed || 'Failed to delete conversation.');
	    } finally {
	      hideDeletePopover();
	    }
	  });

	  // close on Escape or click outside
	  function onKey(e) {
	    if (e.key === 'Escape') {
	      hideDeletePopover();
	    }
	  }
	  function onDocClick(e) {
	    if (!pop.contains(e.target) && e.target !== anchorEl) {
	      hideDeletePopover();
	    }
	  }

	  document.addEventListener('keydown', onKey);
	  setTimeout(() => document.addEventListener('click', onDocClick), 0); // deferred to avoid immediate close on click

	  pop._cleanup = () => {
	    document.removeEventListener('keydown', onKey);
	    document.removeEventListener('click', onDocClick);
	  };

	  currentDeletePopover = pop;
	  pop.focus();
	  return pop;
	}

	function hideDeletePopover() {
	  if (!currentDeletePopover) return;
	  const p = currentDeletePopover;
	  if (p._cleanup) p._cleanup();
	  p.remove();
	  currentDeletePopover = null;
	}

	/* Small HTML-escape helper (reused) */
	function escapeHtml(s) {
	  if (!s) return '';
	  return String(s)
	    .replace(/&/g, "&amp;")
	    .replace(/</g, "&lt;")
	    .replace(/>/g, "&gt;")
	    .replace(/"/g, "&quot;")
	    .replace(/'/g, "&#039;");
	}

	
    function handleFileSelection() {}

	function streamSSE(reader, onEvent) {
	  const dec = new TextDecoder();
	  let buf = '';

	  async function loop() {
	    while (true) {
	      const { value, done } = await reader.read();
	      if (done) break;
	      buf += dec.decode(value, { stream: true });
	      let idx;

	      while ((idx = buf.indexOf('\n\n')) !== -1) {
	        const raw = buf.slice(0, idx).trim();
	        buf = buf.slice(idx + 2);

	        let name = null;
	        let data = '';

	        raw.split(/\r?\n/).forEach(l => {
	          if (l.startsWith('event:'))    name = l.slice(6).trim();
	          else if (l.startsWith('data:')) data += l.slice(5).trim();
	        });

	        if (name) {
	          onEvent(name, data);
	        }
	      }
	    }
	  }

	  loop().catch(console.error);
	}

	function uploadPDF(event) {
	  event.preventDefault();

	  const files        = document.getElementById('sourceFile').files;
	  const progressBar  = document.getElementById('progressBar');
	  const uploadBtn    = document.getElementById('uploadButton');
	  const successDiv   = document.getElementById('success');
	  const errorDiv     = document.getElementById('error');
	  const spinner      = document.getElementById('uploadSpinner');

	  if (!files.length) {
	    errorDiv.textContent = 'Please select at least one file.';
	    errorDiv.classList.remove('hidden');
	    return;
	  }

	  errorDiv.classList.add('hidden');
	  successDiv.classList.add('hidden');
	  document.getElementById('progressContainer').classList.remove('hidden');
	  spinner.classList.remove('hidden');
	  uploadBtn.disabled = true;
	  progressBar.style.width = '0%';

	  const form = new FormData();
	  for (const f of files) form.append('files', f);

	  fetch('/document/analyze', {
	    method: 'POST',
	    body:   form,
	    headers: { 'Accept': 'text/event-stream' }
	  })
	  .then(resp => {
	    if (!resp.ok) throw new Error('upload failed');
	    streamSSE(resp.body.getReader(), (evt, json) => {
 		  const data = json ? JSON.parse(json) : {};  
	      console.log("SSE event:", evt, data);
		  if (!evt || evt === "") return;

	      switch (evt) {
	        case 'fileDone':
              appendPDFRow(data.file, data.language);
	          progressBar.style.width = `${data.progressPercent || 0}%`;
	          break;
	        case 'jobComplete':
	          progressBar.style.width = '100%';
	          successDiv.textContent  = `âœ”ï¸ Embedded ${data.totalChunks} chunks in ${data.elapsed}s`;
	          successDiv.classList.remove('hidden');
	          cleanup();
	          break;
	        case 'error':
	          throw new Error(data.message || 'server error');
	      }
	    });
	  })
	  .catch(err => {
	    console.error(err);
	    errorDiv.textContent = 'An error occurred while uploading the files.';
	    errorDiv.classList.remove('hidden');
	    cleanup();
	  });

	  function cleanup() {
	    spinner.classList.add('hidden');
	    uploadBtn.disabled = false;
	    document.getElementById('progressContainer').classList.add('hidden');
	  }
	}

	function loadExistingDocs() {
	  const pdfList = document.getElementById("pdfList");
	  pdfList.innerHTML = "";

	  fetch('/document/list')
	    .then(res => {
	      if (!res.ok) throw new Error("Could not load existing docs");
	      return res.json();
	    })
		.then(docs => {
		  docs.forEach(doc => appendPDFRow(doc.filename, doc.language));
		})
	    .catch(err => {
	      console.error("Error loading existing docs:", err);
	    });
	}

	function appendPDFRow(fileName, languageCode) {
	  const pdfList = document.getElementById("pdfList");
	  const userUI = userLang; 
	  const langLabel = (langLabels[userUI] || {})[languageCode] || languageCode;

	  const row = document.createElement("tr");
	  row.dataset.langcode = languageCode;

	  row.innerHTML = `
	    <td class="filename-cell">${fileName}</td>
	    <td>${langLabel}</td>
	  `;
	  pdfList.appendChild(row);
	}

    function clearDocuments() {
      fetch("/document/clearDocuments", { method: "POST" })
      .then(response => {
        if (!response.ok) throw new Error("Failed to clear documents");
        document.getElementById("pdfList").innerHTML = "";
        document.getElementById("success").textContent = "Documents cleared successfully.";
        document.getElementById("success").classList.remove("hidden");
      })
      .catch(() => {
        document.getElementById("error").textContent = "An error occurred while clearing documents.";
        document.getElementById("error").style.display = "block";
      });
    }

    function togglePane() {
      const uploadSection = document.getElementById("uploadSection");
      const toggleButton = document.getElementById("toggleButton");
      uploadSection.classList.toggle("shrunk");
      toggleButton.textContent = uploadSection.classList.contains("shrunk") ? ">" : "<";
    }

    function toggleThinkingDisplay(event) {
      event.preventDefault();
      showThinkingBlock = !showThinkingBlock;
      const toggleLink = document.getElementById("toggleThinkingDisplay");
      toggleLink.textContent = showThinkingBlock ? translations[userLang].toggleThinkingHide : translations[userLang].toggleThinkingShow;
      if (currentThinkingMessageElement) {
        if (showThinkingBlock) {
          currentThinkingMessageElement.classList.remove("hide-thinking-message");
        } else {
          currentThinkingMessageElement.classList.add("hide-thinking-message");
        }
      }
    }

    // ===== Conversations: helpers =====
    function chatLabelFromId(id) {
      return id.slice(0, 8); // temporary until titles exist
    }

	/** small helper to escape HTML for safety */
	function escapeHtml(s) {
	  return s
	    .replace(/&/g, "&amp;")
	    .replace(/</g, "&lt;")
	    .replace(/>/g, "&gt;")
	    .replace(/"/g, "&quot;")
	    .replace(/'/g, "&#039;");
	}

	function renderConversationList(conversations) {
	  const list = document.getElementById("chatList");
	  list.innerHTML = "";

	  (conversations || []).forEach(item => {
	    const id = (typeof item === "string") ? item : (item.id || item.conversationId || "");
	    let title = (typeof item === "string") ? "" : (item.title || "");
	    if (!title || title.trim() === "" || title === "...") {
	      title = chatLabelFromId(id);
	    }

	    const li = document.createElement("li");
	    li.className = "chat-list-item";
	    li.dataset.cid = id;

	    // Use simple flex layout inside LI to keep title and delete button aligned
	    li.innerHTML = `
	      <div style="display:flex; align-items:center; justify-content:space-between; gap:8px;">
	        <span class="chat-title" style="flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; display:inline-block; cursor:pointer;">
	          ${escapeHtml(title)}
	        </span>
	        <button class="delete-conv-btn" title="Delete conversation" aria-label="Delete conversation" style="border:none;background:transparent;cursor:pointer;padding:2px 6px;font-weight:600;">
	          âœ•
	        </button>
	      </div>
	    `;

	    // Click the title to switch conversation
	    li.querySelector('.chat-title').addEventListener('click', () => switchChat(id));

	    // Delete handler (stopPropagation so it won't trigger the switch)
		li.querySelector('.delete-conv-btn').addEventListener('click', (e) => {
		  e.stopPropagation();
		  const idToDelete = id;
		  const titleForUI = title;

		  showDeletePopover(e.currentTarget, {
		    id: idToDelete,
		    title: titleForUI,
		    message: translations[userLang]?.confirmDeleteConversation,
		    onConfirm: async () => {
		      const resp = await fetch(`/document/conversations/${encodeURIComponent(idToDelete)}`, { method: 'DELETE' });
		      if (!resp.ok) {
		        if (resp.status === 404) throw new Error('Conversation not found (already deleted).');
		        throw new Error('Failed to delete conversation');
		      }
		      // remove from list UI
		      if (li && li.parentNode) li.parentNode.removeChild(li);
		      // clear active conversation if necessary
		      if (activeConversationId === idToDelete) {
		        activeConversationId = null;
		        const chatMessages = document.getElementById("chatMessages");
		        if (chatMessages) chatMessages.innerHTML = '';
		      }
		    },
		    onCancel: () => {
		      // optional analytics or focus back to list
		      const list = document.getElementById('chatList');
		      if (list) list.focus();
		    }
		  });
		});

	    list.appendChild(li);
	  });

	  highlightActiveConversation();
	}

	// call this once on page load
	function subscribeConversationEvents() {
	  try {
	    const es = new EventSource('/document/events');

	    es.addEventListener('conversationTitleUpdated', (ev) => {
	      try {
	        const payload = JSON.parse(ev.data);
	        const cid = payload.conversationId;
	        const title = payload.title;
	        updateConversationTitleInDOM(cid, title);
	      } catch (err) {
	        console.error('Bad event payload', err);
	      }
	    });

		es.addEventListener('conversationDeleted', (ev) => {
		  try {
		    const payload = JSON.parse(ev.data);
		    const cid = payload.conversationId;
		    const list = document.getElementById('chatList');
		    if (!list) return;
		    const li = list.querySelector(`[data-cid="${cid}"]`);
		    if (li) li.remove();
		    if (activeConversationId === cid) {
		      activeConversationId = null;
		      document.getElementById('chatMessages').innerHTML = '';
		    }
		  } catch (err) {
		    console.error('Bad conversationDeleted payload', err);
		  }
		});
		
	    es.onopen = () => console.log('SSE connected');
	    es.onerror = (e) => {
	      // EventSource auto-reconnects; log for debugging.
	      console.warn('SSE error', e);
	    };

	    // store es if you ever want to close it: window.convEventSource = es;
	  } catch (e) {
	    console.error('SSE not supported', e);
	  }
	}

	function updateConversationTitleInDOM(conversationId, title) {
	  const list = document.getElementById('chatList');
	  if (!list) return;
	  const li = list.querySelector(`[data-cid="${conversationId}"]`);
	  if (li) {
	    li.textContent = title || li.textContent;
	  } else {
	    // Not found â€” maybe list hasn't loaded. Optionally reload conversations.
	    // loadConversations(); // uncomment if you prefer full refresh
	    console.log('Updated title for non-visible conversation', conversationId, title);
	  }
	}

	
	
    function highlightActiveConversation() {
      document.querySelectorAll("#chatList .chat-list-item").forEach(li => {
        li.classList.toggle("active", li.dataset.cid === activeConversationId);
      });
    }

	async function loadConversations() {
	  try {
	    const res = await fetch("/document/conversations");
	    if (!res.ok) throw new Error("Failed to load conversations");
	    const convs = await res.json(); // array of Conversation objects (or strings)
	    renderConversationList(convs);

	    // Auto-open first conversation if none active
	    if (!activeConversationId) {
	      if (convs && convs.length > 0) {
	        const firstId = (typeof convs[0] === "string") ? convs[0] : (convs[0].id || convs[0].conversationId);
	        if (firstId) await switchChat(firstId);
	      } else {
	        await newChat();
	      }
	    }
	  } catch (e) {
	    console.error("Failed to load conversations:", e);
	  }
	}

	async function newChat() {
	  try {
	    const res = await fetch("/document/conversations", { method: "POST" });
	    if (!res.ok) throw new Error("Failed to create conversation");
	    const newId = await res.text();

	    // Set active and add to list
	    activeConversationId = newId;
	    const list = document.getElementById("chatList");
	    const li = document.createElement("li");
	    li.className = "chat-list-item active";
	    li.dataset.cid = newId;
	    li.textContent = chatLabelFromId(newId);
	    li.addEventListener("click", () => switchChat(newId));
	    list.prepend(li);

	    highlightActiveConversation();

	    // Clear the viewport and open the new (empty) conversation
	    document.getElementById("chatMessages").innerHTML = "";
	    // Load messages (likely empty) so UI is consistent
	    await switchChat(newId);
	  } catch (e) {
	    console.error("Failed to create conversation:", e);
	  }
	}

	async function switchChat(conversationId) {
	  try {
	    if (!conversationId) return;

	    activeConversationId = conversationId;
	    highlightActiveConversation();

	    console.log('Fetching messages for conversation:', conversationId);
	    const res = await fetch(`/document/conversations/${encodeURIComponent(conversationId)}/messages`);
	    if (!res.ok) {
	      console.error('Failed to load messages, status:', res.status);
	      throw new Error('Failed to load messages');
	    }

	    const messages = await res.json();
	    console.log('Raw messages response for', conversationId, messages);

	    const chatMessages = document.getElementById("chatMessages");
	    chatMessages.innerHTML = "";

	    // preserved thinking element for this conversation (may be undefined)
	    const preserved = thinkingElementsByConversation[conversationId];

	    // If there are no messages, prefer to show the preserved thinking element (if any),
	    // otherwise show the "no messages" notice.
	    if (!messages || messages.length === 0) {
	      if (preserved) {
	        // preserved is a wrapper; append it (no messages to order it against)
	        chatMessages.appendChild(preserved);
	        currentThinkingMessageElement = preserved.querySelector('.response-message') || null;
	      } else {
	        const notice = document.createElement('div');
	        notice.className = 'no-messages-notice text-gray-500 p-2';
	        notice.textContent = translations[userLang]?.noMessages || 'No messages in this conversation.';
	        chatMessages.appendChild(notice);
	      }
	      return;
	    }

	    // Render existing messages first (so user messages exist in DOM)
	    messages.forEach(msg => {
	      const rawRole = (msg.role || msg.messageType || msg.author || msg.sender || "").toString().toLowerCase();
	      let roleCategory;
	      if (rawRole.indexOf('user') !== -1 || rawRole.indexOf('human') !== -1) roleCategory = 'user';
	      else if (rawRole.indexOf('assist') !== -1 || rawRole.indexOf('bot') !== -1) roleCategory = 'assistant';
	      else roleCategory = 'assistant';

	      const text = extractMessageText(msg);

	      if (roleCategory === "user") {
	        appendUserMessage(text);
	      } else {
	        appendAssistantFinal(text);
	      }
	    });

	    // AFTER rendering messages, insert preserved thinking element (if present)
	    if (preserved) {
	      const userMsgs = chatMessages.querySelectorAll('.flex.justify-end');
	      if (userMsgs && userMsgs.length) {
	        userMsgs[userMsgs.length - 1].insertAdjacentElement('afterend', preserved);
	      } else {
	        chatMessages.appendChild(preserved);
	      }
	      currentThinkingMessageElement = preserved.querySelector('.response-message') || null;
	    }

	    chatMessages.scrollTop = chatMessages.scrollHeight;
	  } catch (e) {
	    console.error("Error switching chat:", e);
	    const chatMessages = document.getElementById("chatMessages");
	    if (chatMessages) {
	      const err = document.createElement('div');
	      err.className = 'text-red-600 p-2';
	      err.textContent = 'Failed to load conversation messages.';
	      chatMessages.appendChild(err);
	    }
	  }
	}


	function removeNoMessagesNotice() {
	  const chatMessages = document.getElementById("chatMessages");
	  if (!chatMessages) return;
	  const notice = chatMessages.querySelector('.no-messages-notice');
	  if (notice) notice.remove();
	}



	function extractMessageText(msg) {
	  if (!msg) return '';

	  // 0) explicit 'text' field (your example uses "text")
	  if (typeof msg.text === 'string' && msg.text.trim()) return msg.text;

	  // 1) direct content field as string
	  if (typeof msg.content === 'string' && msg.content.trim()) return msg.content;

	  // 2) content might be an array (e.g. [{type:'text', text:'...'}, 'more'])
	  if (Array.isArray(msg.content)) {
	    try {
	      return msg.content.map(p => {
	        if (typeof p === 'string') return p;
	        if (p && typeof p.text === 'string') return p.text;
	        if (p && typeof p.content === 'string') return p.content;
	        return JSON.stringify(p);
	      }).join('\n\n');
	    } catch (e) {
	      return String(msg.content);
	    }
	  }

	  // 3) some libs return {content: {parts: [...]}} or {content: {text: "..."}} or {message: "..."}
	  if (msg.content && typeof msg.content === 'object') {
	    if (Array.isArray(msg.content.parts)) {
	      return msg.content.parts.map(p => (typeof p === 'string' ? p : (p.text || p.content || JSON.stringify(p)))).join('\n\n');
	    }
	    if (typeof msg.content.text === 'string') return msg.content.text;
	    if (typeof msg.content.content === 'string') return msg.content.content;
	  }

	  // 4) some shapes use msg.message or msg.body
	  if (typeof msg.message === 'string') return msg.message;
	  if (typeof msg.body === 'string') return msg.body;

	  // 5) maybe metadata holds text (rare)
	  if (msg.metadata && typeof msg.metadata.text === 'string') return msg.metadata.text;

	  // last resort: stringify small object
	  try {
	    return JSON.stringify(msg).slice(0, 1000);
	  } catch (e) {
	    return '';
	  }
	}




	function appendUserMessage(text) {
	  // remove any "no messages" notice before adding real content
	  removeNoMessagesNotice();

	  const chatMessages = document.getElementById("chatMessages");
	  const userWrapper = document.createElement("div");
	  userWrapper.className = "flex justify-end";
	  const userMessage = document.createElement("div");
	  userMessage.className = "bg-indigo-500 text-white p-4 rounded-lg max-w-md w-fit";
	  userMessage.dir = userLang === "he" ? "rtl" : "ltr";
	  userMessage.style.textAlign = userLang === "he" ? "right" : "left";
	  userMessage.textContent = text;
	  userWrapper.appendChild(userMessage);
	  chatMessages.appendChild(userWrapper);

	  // keep viewport scrolled
	  chatMessages.scrollTop = chatMessages.scrollHeight;
	}


	function appendAssistantThinking() {
	  // remove any "no messages" notice before showing thinking
	  removeNoMessagesNotice();

	  const chatMessages = document.getElementById("chatMessages");

	  const responseWrapper = document.createElement("div");
	  responseWrapper.className = "flex justify-start thinking-wrapper";

	  const responseMessage = document.createElement("div");
	  responseMessage.className = "bg-gray-200 text-black rounded-lg w-fit whitespace-pre-wrap response-message is-thinking thinking-glow";
	  if (!showThinkingBlock) responseMessage.classList.add("hide-thinking-message");

	  // tag it with the conversation id so we can reattach later
	  const cid = activeConversationId || DEFAULT_CONVERSATION_ID || "default";
	  responseMessage.dataset.thinkingFor = cid;

	  responseWrapper.appendChild(responseMessage);

	  // Try to insert AFTER the last user bubble. If none, append to end.
	  const userMsgs = chatMessages.querySelectorAll('.flex.justify-end');
	  if (userMsgs && userMsgs.length) {
	    const lastUser = userMsgs[userMsgs.length - 1];
	    lastUser.insertAdjacentElement('afterend', responseWrapper);
	  } else {
	    chatMessages.appendChild(responseWrapper);
	  }

	  // store element reference so switching away and back can reattach it
	  thinkingElementsByConversation[cid] = responseWrapper;
	  currentThinkingMessageElement = responseMessage;

	  responseMessage.innerHTML = showThinkingBlock
	    ? `<div class="thinking-indicator"><img src="logo.png" alt="Logo"><span>×—×•×©×‘...</span></div>`
	    : "";

	  chatMessages.scrollTop = chatMessages.scrollHeight;
	  return responseMessage;
	}



	function finalizeAssistantMessage(el, html) {
	  // remove any "no messages" notice if final answer arrives
	  removeNoMessagesNotice();

	  // remove from stored thinking map (element may be somewhere else)
	  const cid = (el && el.dataset && el.dataset.thinkingFor) || activeConversationId || DEFAULT_CONVERSATION_ID || "default";
	  if (thinkingElementsByConversation[cid]) {
	    delete thinkingElementsByConversation[cid];
	  }

	  el.classList.remove("hide-thinking-message", "is-thinking", "thinking-glow");
	  el.classList.add("final-answer", "p-4");
	  el.dir = userLang === "he" ? "rtl" : "ltr";
	  el.style.textAlign = userLang === "he" ? "right" : "left";
	  currentThinkingMessageElement = null;
	  el.innerHTML = marked.parse(html);
	}


	function appendAssistantFinal(text) {
	  removeNoMessagesNotice();

	  const wrapper = document.createElement("div");
	  wrapper.className = "flex justify-start";
	  const msg = document.createElement("div");
	  msg.className = "bg-gray-200 text-black rounded-lg w-fit whitespace-pre-wrap response-message final-answer p-4";
	  msg.dir = userLang === "he" ? "rtl" : "ltr";
	  msg.style.textAlign = userLang === "he" ? "right" : "left";
	  msg.innerHTML = marked.parse((text || "").toString());
	  wrapper.appendChild(msg);
	  document.getElementById("chatMessages").appendChild(wrapper);

	  // scroll down
	  const chatMessages = document.getElementById("chatMessages");
	  chatMessages.scrollTop = chatMessages.scrollHeight;
	}


    function handleChatSubmit(event) {
      event.preventDefault();
      const chatInput = document.getElementById("chatInput");
      const chatMessages = document.getElementById("chatMessages");
      const question = chatInput.value.trim();
      if (!question) return;

      // Ensure we have an active conversation; if not, create one
      const ensureConversation = activeConversationId
        ? Promise.resolve(activeConversationId)
        : fetch("/document/conversations", { method: "POST" })
            .then(r => {
              if (!r.ok) throw new Error("Failed to create conversation");
              return r.text();
            })
            .then(id => {
              activeConversationId = id;
              // put it at the top of the list
              const list = document.getElementById("chatList");
              const li = document.createElement("li");
              li.className = "chat-list-item active";
              li.dataset.cid = id;
              li.textContent = chatLabelFromId(id);
              li.addEventListener("click", () => switchChat(id));
              list.prepend(li);
              highlightActiveConversation();
              return id;
            });

      ensureConversation.then(() => {
        appendUserMessage(question);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        chatInput.value = "";

        const headers = {
          "Content-Type": "text/plain",
          "X-Chat-Language": userLang,
          "X-Conversation-ID": activeConversationId
        };

        const responseMessage = appendAssistantThinking();

        let fullContent = "";
        fetch("/document/query", {
          method: "POST",
          headers,
          body: question,
        })
        .then(response => {
          if (!response.ok) throw new Error("Failed to process question");
          return response.body.getReader();
        })
        .then(reader => {
          const decoder = new TextDecoder();

          function read() {
            reader.read().then(({ done, value }) => {
              if (done) {
                const clean = fullContent.replace(/<think>[\s\S]*?<\/think>/g, "").trim();
                finalizeAssistantMessage(responseMessage, clean);
                return;
              }
              const chunk = decoder.decode(value, { stream: true });
              fullContent += chunk;

              // Show final answer as soon as any visible content appears
              const withoutThink = fullContent.replace(/<think>[\s\S]*?<\/think>/g, '').trim();
              if (withoutThink) {
                finalizeAssistantMessage(responseMessage, withoutThink);
              }

              // Optionally show the thinking block if present and enabled
              if (showThinkingBlock && fullContent.includes("<think>")) {
                const match = fullContent.match(/<think>([\s\S]*?)<\/think>/);
                if (match && match[1]) {
                  if (!responseMessage.querySelector('.thinking-text')) {
                    responseMessage.innerHTML = `<div class="thinking-indicator"><img src="logo.png"><div class="thinking-text"></div></div>`;
                  }
                  const thinkingDiv = responseMessage.querySelector('.thinking-text');
                  thinkingDiv.textContent = match[1].trim();
                }
              }
              chatMessages.scrollTop = chatMessages.scrollHeight;
              read();
            });
          }
          read();
        })
        .catch(() => {
          responseMessage.innerHTML = "×©×’×™××” ×‘×¢×™×‘×•×“ ×”×©××œ×”.";
          responseMessage.classList.remove("thinking-glow", "is-thinking", "hide-thinking-message");
          responseMessage.classList.add("final-answer", "p-4");
          currentThinkingMessageElement = null;
        });
      });
    }

	const translations = {
	  en: {
	    title: "Document Analyzer",
	    chooseFiles: "Choose Documents in English:",
	    upload: "Upload",
	    clearFiles: "Clear Documents",
	    toggleThinkingShow: "Show Thinking",
	    toggleThinkingHide: "Hide Thinking",
	    inputPlaceholder: "How can I help?",
	    send: "Send",
	    toggleLanguage: "Switch Language",
	    uploadedDocuments: "Loaded Documents:",
	    processing: "Processing documents...",
	    headerFilename: "Filename",
	    headerLang: "Lang",
	    chatsTitle: "Chats",
	    newChat: "New Chat",
	    noMessages: "No messages in this conversation.",
		confirmDeleteConversation: "Delete conversation?",
		deleteFailed: "Failed to delete conversation.",
		confirmDeleteBtn: "Delete",
		cancelBtn: "Cancel",
		confirmDeleteConversation: "Delete this conversation?"

	  },
	  he: {
	    title: "×¡×™×™×¢×Ÿ ×”××¡××›×™×",
	    chooseFiles: "×‘×—×¨ ××¡××›×™× ×‘×¢×‘×¨×™×ª ×‘×œ×‘×“:",
	    upload: "×”×¢×œ×”",
	    clearFiles: "× ×§×” ××¡××›×™×",
	    toggleThinkingShow: "×”×¦×’ ×—×©×™×‘×”",
	    toggleThinkingHide: "×”×¡×ª×¨ ×—×©×™×‘×”",
	    inputPlaceholder: "××™×š ××¤×©×¨ ×œ×¢×–×•×¨?",
	    send: "×©×œ×—",
	    toggleLanguage: "×”×—×œ×£ ×©×¤×”",
	    uploadedDocuments: "××¡××›×™× ×©× ×˜×¢× ×•:",
	    processing: "××¢×‘×“ ××¡××›×™×...",
	    headerFilename: "×©× ×§×•×‘×¥",
	    headerLang: "×©×¤×”",
	    chatsTitle: "×©×™×—×•×ª",
	    newChat: "×©×™×—×” ×—×“×©×”",
	    noMessages: "××™×Ÿ ×”×•×“×¢×•×ª ×‘×©×™×—×” ×–×•.",
		confirmDeleteConversation: "×”×× ×œ××—×•×§ ××ª ×”×©×™×—×”?",
		deleteFailed: "× ×›×©×œ ×‘× ×™×¡×™×•×Ÿ ×œ××—×•×§ ××ª ×”×©×™×—×”.",
		confirmDeleteBtn: "××—×§",
		cancelBtn: "×‘×™×˜×•×œ",
		confirmDeleteConversation: "×”×× ×œ××—×•×§ ××ª ×”×©×™×—×” ×”×–×•?"

	  }
	};


    let userLang = navigator.language.startsWith("he") ? "he" : "en";

    function applyTranslations(lang) {
      userLang = lang;
	  const t = translations[lang];

      document.documentElement.lang = lang;
      document.documentElement.dir = lang === "he" ? "rtl" : "ltr";

      document.title = t.title;
      document.querySelector("h1").textContent = t.title;
      document.querySelector("label[for='sourceFile']").textContent = t.chooseFiles;
      document.getElementById("uploadButton").textContent = t.upload;
      document.querySelector("button[onclick='clearDocuments()']").textContent = t.clearFiles;
	  document.getElementById("toggleThinkingDisplay").textContent =
	    showThinkingBlock ? t.toggleThinkingHide : t.toggleThinkingShow;
      document.getElementById("chatInput").placeholder = t.inputPlaceholder;
      document.getElementById("sendButton").textContent = t.send;
      document.getElementById("languageToggle").textContent = "ğŸŒ " + t.toggleLanguage;
	  document.getElementById("uploadedDocumentsTitle").textContent = t.uploadedDocuments;
	  document.getElementById("processingText").textContent = t.processing;
	  document.getElementById("filenameHeader").textContent  = t.headerFilename;
	  document.getElementById("languageHeader").textContent = t.headerLang;

	  // Update language labels in the docs table body
	  document.querySelectorAll("#pdfList tr").forEach(row => {
	    const langCode = row.dataset.langcode;
	    if (!langCode) return;
	    row.children[1].textContent =
	      (langLabels[lang] || {})[langCode] || langCode;
	  });

      // Chats header / button (do NOT overwrite items now that theyâ€™re real IDs)
      const chatsTitleEl = document.getElementById("chatsTitle");
      const newChatBtn = document.getElementById("newChatBtn");
      if (chatsTitleEl) chatsTitleEl.textContent = t.chatsTitle;
      if (newChatBtn) newChatBtn.textContent = t.newChat;

      // Update text direction and alignment of chat input
      const chatInput = document.getElementById("chatInput");
      chatInput.dir = lang === "he" ? "rtl" : "ltr";
      chatInput.style.textAlign = lang === "he" ? "right" : "left";
	  updateToggleButtonPosition(lang);
    }

	function updateToggleButtonPosition(lang) {
	  const toggleButton = document.getElementById("toggleButton");
	  if (lang === "he") {
	    toggleButton.style.left = "-1rem";
	    toggleButton.style.right = "auto";
	  } else {
	    toggleButton.style.right = "-1rem";
	    toggleButton.style.left = "auto";
	  }
	}

	document.addEventListener("DOMContentLoaded", () => {
	  applyTranslations(userLang);
	  loadExistingDocs();

      // Enter to send
      document.getElementById("chatInput").addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          e.target.closest("form").requestSubmit();
        }
      });

	  document.getElementById("languageToggle").addEventListener("click", (e) => {
	    e.preventDefault();
	    const toggledLang = userLang === "he" ? "en" : "he";
	    applyTranslations(toggledLang);
	  });

      // New Chat button â†’ real backend POST
      const btn = document.getElementById("newChatBtn");
      if (btn) btn.addEventListener("click", newChat);

      // Load conversations from backend; creates one if none exist
      loadConversations();
	  subscribeConversationEvents();
	});
  </script>
  </head>

  <body class="bg-gray-100 h-full flex flex-col overflow-auto">
    <div class="flex-container">
      <div id="uploadSection" class="flex-shrink-0">
        <div id="toggleButton" onclick="togglePane()">&lt;</div>
        <h1>×¡×™×™×¢×Ÿ ×”××¡××›×™×</h1>
        <form onsubmit="uploadPDF(event)" class="w-full">
          <label for="sourceFile" class="block text-right">×‘×—×¨ ××¡××›×™×:</label>
          <input type="file" id="sourceFile" multiple onchange="handleFileSelection()" required />
          <button type="submit" id="uploadButton">Upload</button>
          <div id="progressContainer" class="hidden mt-2">
            <div class="h-1.5 bg-gray-200 rounded-full overflow-hidden">
              <div id="progressBar" class="h-full bg-indigo-500" style="width: 0%"></div>
            </div>
          </div>

		  <div id="uploadSpinner" class="hidden flex items-center justify-center mt-2">
		    <svg class="animate-spin h-5 w-5 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
		      <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
		      <path class="opacity-75" fill="currentColor"
		        d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z" />
		    </svg>
			<span id="processingText" class="ml-2 text-sm text-gray-700"></span>
		  </div>

          <div id="error" class="hidden"></div>
          <div id="success" class="hidden"></div>
        </form>

        <div class="mt-4 w-full">
          <h2 id="uploadedDocumentsTitle" class="text-lg font-semibold mb-2 text-right">××¡××›×™× ×©× ×˜×¢× ×•:</h2>
		  <div class="pdf-table-wrapper">
		  <table id="pdfTable" class="w-full border border-gray-300">
			<colgroup>
			  <col style="width: 70%;">
			  <col style="width: 30%;">
			</colgroup>
		    <thead>
		      <tr>
				<th id="filenameHeader"  class="p-2">Filename</th>
				<th id="languageHeader" class="p-2">Lang</th>
		      </tr>
		    </thead>
		    <tbody id="pdfList"></tbody>
		  </table>
		  </div>

          <button type="button" onclick="clearDocuments()" class="mt-2 bg-red-600 hover:bg-red-700 text-white w-full py-2 rounded">
            × ×§×” ××¡××›×™×
          </button>

          <!-- Chats list UI -->
          <div id="chatsSection" class="mt-4">
            <h2 id="chatsTitle" class="text-lg font-semibold text-right">×©×™×—×•×ª</h2>
            <ul id="chatList" aria-label="Chats"></ul>
            <button type="button" id="newChatBtn" class="mt-2">×©×™×—×” ×—×“×©×”</button>
          </div>

          <div class="mt-auto pt-4 text-center">
            <button id="languageToggle" class="text-sm text-blue-600 hover:text-blue-800">ğŸŒ English</button>
          </div>
        </div>
      </div>

      <div class="chat-section">
        <div id="chatMessages"></div>
		<form onsubmit="handleChatSubmit(event)" class="flex flex-col gap-2">
		  <div class="flex gap-2">
		    <textarea
		      id="chatInput"
		      placeholder="××™×š ××¤×©×¨ ×œ×¢×–×•×¨?"
		      class="flex-grow resize-none"
		      dir="rtl"
		      style="height: 3.5em; line-height: 1.4em;"
		    ></textarea>
		    <button type="submit" id="sendButton">×©×œ×—</button>
		  </div>
		  <div class="text-center">
		    <a
		      href="#"
		      id="toggleThinkingDisplay"
		      class="text-blue-600 hover:text-blue-800"
		      onclick="toggleThinkingDisplay(event)"
		      >×”×¦×’ ×—×©×™×‘×”</a
		    >
		  </div>
		</form>
      </div>
    </div>
  </body>
  </html>
